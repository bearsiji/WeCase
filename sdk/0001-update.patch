From 821d7c5f28c87191c3f60300e526eaa4d72e710b Mon Sep 17 00:00:00 2001
From: Li Jianzhi <garfield_550@sina.cn>
Date: Tue, 5 Feb 2013 13:10:35 +0800
Subject: [PATCH] update

---
 PythonSDK/michaelliao-sinaweibopy-2e8ee51.tar.gz   |  Bin 0 -> 8468 bytes
 .../michaelliao-sinaweibopy-2e8ee51/.gitignore     |   47 +++
 .../michaelliao-sinaweibopy-2e8ee51/CHANGES.txt    |   19 ++
 .../michaelliao-sinaweibopy-2e8ee51/LICENSE.txt    |  202 +++++++++++++
 PythonSDK/michaelliao-sinaweibopy-2e8ee51/README   |   12 +
 PythonSDK/michaelliao-sinaweibopy-2e8ee51/setup.py |   30 ++
 PythonSDK/michaelliao-sinaweibopy-2e8ee51/weibo.py |  306 ++++++++++++++++++++
 .../michaelliao-sinaweibopy-2e8ee51/weibo.py~      |  306 ++++++++++++++++++++
 8 files changed, 922 insertions(+)
 create mode 100644 PythonSDK/michaelliao-sinaweibopy-2e8ee51.tar.gz
 create mode 100644 PythonSDK/michaelliao-sinaweibopy-2e8ee51/.gitignore
 create mode 100644 PythonSDK/michaelliao-sinaweibopy-2e8ee51/CHANGES.txt
 create mode 100644 PythonSDK/michaelliao-sinaweibopy-2e8ee51/LICENSE.txt
 create mode 100644 PythonSDK/michaelliao-sinaweibopy-2e8ee51/README
 create mode 100644 PythonSDK/michaelliao-sinaweibopy-2e8ee51/setup.py
 create mode 100644 PythonSDK/michaelliao-sinaweibopy-2e8ee51/weibo.py
 create mode 100644 PythonSDK/michaelliao-sinaweibopy-2e8ee51/weibo.py~

diff --git a/PythonSDK/michaelliao-sinaweibopy-2e8ee51.tar.gz b/PythonSDK/michaelliao-sinaweibopy-2e8ee51.tar.gz
new file mode 100644
index 0000000000000000000000000000000000000000..7a74b5eec0ae7ff2e300b147b0f02bdec3f17612
GIT binary patch
literal 8468
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
C27r<P

literal 0
HcmV?d00001

diff --git a/PythonSDK/michaelliao-sinaweibopy-2e8ee51/.gitignore b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/.gitignore
new file mode 100644
index 0000000..aece548
--- /dev/null
+++ b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/.gitignore
@@ -0,0 +1,47 @@
+# 3rd part lib #
+################
+transwarp
+
+# Compiled source #
+###################
+*.com
+*.class
+*.dll
+*.exe
+*.o
+*.so
+*.pyc
+*.pyo
+
+# Packages #
+############
+# it's better to unpack these files and commit the raw source
+# git has its own built in compression methods
+*.7z
+*.dmg
+*.gz
+*.iso
+*.jar
+*.rar
+*.tar
+*.zip
+
+# Logs and databases #
+######################
+*.log
+*.sql
+*.sqlite
+
+# OS generated files #
+######################
+.DS_Store
+.DS_Store?
+._*
+.Spotlight-V100
+.Trashes
+Icon?
+ehthumbs.db
+Thumbs.db
+dist
+MANIFEST
+
diff --git a/PythonSDK/michaelliao-sinaweibopy-2e8ee51/CHANGES.txt b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/CHANGES.txt
new file mode 100644
index 0000000..74f5795
--- /dev/null
+++ b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/CHANGES.txt
@@ -0,0 +1,19 @@
+Version 1.0.5 released 2012-9-26
+
+* Initial release.
+
+Version 1.0.6 released 2012-11-10
+
+* Improve API calling.
+
+Version 1.0.7 released 2012-11-15
+
+* Add more params in get_authorize_url.
+
+Version 1.0.8 released 2012-12-02
+
+* Add gzip support.
+
+Version 1.0.9 released 2012-12-14
+
+* Add in-site app support.
diff --git a/PythonSDK/michaelliao-sinaweibopy-2e8ee51/LICENSE.txt b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/LICENSE.txt
new file mode 100644
index 0000000..d645695
--- /dev/null
+++ b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/LICENSE.txt
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/PythonSDK/michaelliao-sinaweibopy-2e8ee51/README b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/README
new file mode 100644
index 0000000..981d4d0
--- /dev/null
+++ b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/README
@@ -0,0 +1,12 @@
+This software is a 100% Python interface to Sina weibo OAuth2 API. 
+It is the client side software which allows access Sina weibo API. 
+Visit http://open.weibo.com/ for more information.
+
+This package was originally written by Michael Liao. You can find 
+docs and source code at:
+
+http://michaelliao.github.com/sinaweibopy/
+
+Please report bugs or any suggestions at:
+
+https://github.com/michaelliao/sinaweibopy
diff --git a/PythonSDK/michaelliao-sinaweibopy-2e8ee51/setup.py b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/setup.py
new file mode 100644
index 0000000..1046a0d
--- /dev/null
+++ b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/setup.py
@@ -0,0 +1,30 @@
+from distutils.core import setup
+import sys
+
+import weibo
+
+kw = dict(
+    name = 'sinaweibopy',
+    version = weibo.__version__,
+    description = 'Sina Weibo OAuth2 API Python SDK',
+    long_description = open('README', 'r').read(),
+    author = 'Michael Liao',
+    author_email = 'askxuefeng@gmail.com',
+    url = 'https://github.com/michaelliao/sinaweibopy',
+    download_url = 'https://github.com/michaelliao/sinaweibopy',
+    py_modules = ['weibo'],
+    classifiers = [
+        'Development Status :: 5 - Production/Stable',
+        'Environment :: Web Environment',
+        'Intended Audience :: Developers',
+        'License :: OSI Approved :: Apache Software License',
+        'Operating System :: OS Independent',
+        'Programming Language :: Python',
+        'Topic :: Internet',
+        'Topic :: Software Development :: Libraries :: Python Modules',
+    ])
+
+if sys.version_info[1]==5:
+    kw['install_requires'] = ['simplejson']
+
+setup(**kw)
diff --git a/PythonSDK/michaelliao-sinaweibopy-2e8ee51/weibo.py b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/weibo.py
new file mode 100644
index 0000000..ccab475
--- /dev/null
+++ b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/weibo.py
@@ -0,0 +1,306 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+__version__ = '1.0.9'
+__author__ = 'Liao Xuefeng (askxuefeng@gmail.com)'
+
+'''
+Python client SDK for sina weibo API using OAuth 2.
+'''
+
+try:
+    import json
+except ImportError:
+    import simplejson as json
+
+try:
+    from cStringIO import StringIO
+except ImportError:
+    from StringIO import StringIO
+
+import gzip, time, hmac, base64, hashlib, urllib, urllib2, logging, mimetypes
+
+class APIError(StandardError):
+    '''
+    raise APIError if receiving json message indicating failure.
+    '''
+    def __init__(self, error_code, error, request):
+        self.error_code = error_code
+        self.error = error
+        self.request = request
+        StandardError.__init__(self, error)
+
+    def __str__(self):
+        return 'APIError: %s: %s, request: %s' % (self.error_code, self.error, self.request)
+
+def _parse_json(s):
+    ' parse str into JsonDict '
+
+    def _obj_hook(pairs):
+        ' convert json object to python object '
+        o = JsonDict()
+        for k, v in pairs.iteritems():
+            o[str(k)] = v
+        return o
+    return json.loads(s, object_hook=_obj_hook)
+
+class JsonDict(dict):
+    ' general json object that allows attributes to be bound to and also behaves like a dict '
+    def __getattr__(self, attr):
+        return self[attr]
+
+    def __setattr__(self, attr, value):
+        self[attr] = value
+
+    def __getstate__(self):
+        return self.copy()
+
+    def __setstate__(self, state):
+        self.update(state)
+
+def _encode_params(**kw):
+    ' do url-encode parameters '
+    args = []
+    for k, v in kw.iteritems():
+        qv = v.encode('utf-8') if isinstance(v, unicode) else str(v)
+        args.append('%s=%s' % (k, urllib.quote(qv)))
+    return '&'.join(args)
+
+def _encode_multipart(**kw):
+    ' build a multipart/form-data body with randomly generated boundary '
+    boundary = '----------%s' % hex(int(time.time() * 1000))
+    data = []
+    for k, v in kw.iteritems():
+        data.append('--%s' % boundary)
+        if hasattr(v, 'read'):
+            # file-like object:
+            filename = getattr(v, 'name', '')
+            content = v.read()
+            data.append('Content-Disposition: form-data; name="%s"; filename="hidden"' % k)
+            data.append('Content-Length: %d' % len(content))
+            data.append('Content-Type: %s\r\n' % _guess_content_type(filename))
+            data.append(content)
+        else:
+            data.append('Content-Disposition: form-data; name="%s"\r\n' % k)
+            data.append(v.encode('utf-8') if isinstance(v, unicode) else v)
+    data.append('--%s--\r\n' % boundary)
+    return '\r\n'.join(data), boundary
+
+def _guess_content_type(url):
+    n = url.rfind('.')
+    if n==(-1):
+        return 'application/octet-stream'
+    ext = url[n:]
+    mimetypes.types_map.get(ext, 'application/octet-stream')
+
+_HTTP_GET = 0
+_HTTP_POST = 1
+_HTTP_UPLOAD = 2
+
+def _http_get(url, authorization=None, **kw):
+    logging.info('GET %s' % url)
+    return _http_call(url, _HTTP_GET, authorization, **kw)
+
+def _http_post(url, authorization=None, **kw):
+    logging.info('POST %s' % url)
+    return _http_call(url, _HTTP_POST, authorization, **kw)
+
+def _http_upload(url, authorization=None, **kw):
+    logging.info('MULTIPART POST %s' % url)
+    return _http_call(url, _HTTP_UPLOAD, authorization, **kw)
+
+def _read_body(obj):
+    using_gzip = obj.headers.get('Content-Encoding', '')=='gzip'
+    body = obj.read()
+    if using_gzip:
+        logging.info('gzip content received.')
+        gzipper = gzip.GzipFile(fileobj=StringIO(body))
+        fcontent = gzipper.read()
+        gzipper.close()
+        return fcontent
+    return body
+
+def _http_call(the_url, method, authorization, **kw):
+    '''
+    send an http request and return a json object if no error occurred.
+    '''
+    params = None
+    boundary = None
+    if method==_HTTP_UPLOAD:
+        # fix sina upload url:
+        the_url = the_url.replace('https://api.', 'https://upload.api.')
+        params, boundary = _encode_multipart(**kw)
+    else:
+        params = _encode_params(**kw)
+        if '/remind/' in the_url:
+            # fix sina remind api:
+            the_url = the_url.replace('https://api.', 'https://rm.api.')
+    http_url = '%s?%s' % (the_url, params) if method==_HTTP_GET else the_url
+    http_body = None if method==_HTTP_GET else params
+    req = urllib2.Request(http_url, data=http_body)
+    req.add_header('Accept-Encoding', 'gzip')
+    if authorization:
+        req.add_header('Authorization', 'OAuth2 %s' % authorization)
+    if boundary:
+        req.add_header('Content-Type', 'multipart/form-data; boundary=%s' % boundary)
+    try:
+        resp = urllib2.urlopen(req)
+        body = _read_body(resp)
+        r = _parse_json(body)
+        if hasattr(r, 'error_code'):
+            raise APIError(r.error_code, r.get('error', ''), r.get('request', ''))
+        return r
+    except urllib2.HTTPError, e:
+        try:
+            r = _parse_json(_read_body(e))
+        except:
+            r = None
+        if hasattr(r, 'error_code'):
+            raise APIError(r.error_code, r.get('error', ''), r.get('request', ''))
+        raise e
+
+class HttpObject(object):
+
+    def __init__(self, client, method):
+        self.client = client
+        self.method = method
+
+    def __getattr__(self, attr):
+        def wrap(**kw):
+            if self.client.is_expires():
+                raise APIError('21327', 'expired_token', attr)
+            return _http_call('%s%s.json' % (self.client.api_url, attr.replace('__', '/')), self.method, self.client.access_token, **kw)
+        return wrap
+
+class APIClient(object):
+    '''
+    API client using synchronized invocation.
+    '''
+    def __init__(self, app_key, app_secret, redirect_uri=None, response_type='code', domain='api.weibo.com', version='2'):
+        self.client_id = str(app_key)
+        self.client_secret = str(app_secret)
+        self.redirect_uri = redirect_uri
+        self.response_type = response_type
+        self.auth_url = 'https://%s/oauth2/' % domain
+        self.api_url = 'https://%s/%s/' % (domain, version)
+        self.access_token = None
+        self.expires = 0.0
+        self.get = HttpObject(self, _HTTP_GET)
+        self.post = HttpObject(self, _HTTP_POST)
+        self.upload = HttpObject(self, _HTTP_UPLOAD)
+
+    def parse_signed_request(self, signed_request):
+        '''
+        parse signed request when using in-site app.
+
+        Returns:
+            dict object like { 'uid': 12345, 'access_token': 'ABC123XYZ', 'expires': unix-timestamp },
+            or None if parse failed.
+        '''
+
+        def _b64_normalize(s):
+            appendix = '=' * (4 - len(s) % 4)
+            return s.replace('-', '+').replace('_', '/') + appendix
+
+        sr = str(signed_request)
+        logging.info('parse signed request: %s' % sr)
+        enc_sig, enc_payload = sr.split('.', 1)
+        sig = base64.b64decode(_b64_normalize(enc_sig))
+        data = _parse_json(base64.b64decode(_b64_normalize(enc_payload)))
+        if data['algorithm'] != u'HMAC-SHA256':
+            return None
+        expected_sig = hmac.new(self.client_secret, enc_payload, hashlib.sha256).digest();
+        if expected_sig==sig:
+            data.user_id = data.uid = data.get('user_id', None)
+            data.access_token = data.get('oauth_token', None)
+            expires = data.get('expires', None)
+            if expires:
+                data.expires = data.expires_in = time.time() + expires
+            return data
+        return None
+
+    def set_access_token(self, access_token, expires):
+        self.access_token = str(access_token)
+        self.expires = float(expires)
+
+    def get_authorize_url(self, redirect_uri=None, **kw):
+        '''
+        return the authorization url that the user should be redirected to.
+        '''
+        redirect = redirect_uri if redirect_uri else self.redirect_uri
+        if not redirect:
+            raise APIError('21305', 'Parameter absent: redirect_uri', 'OAuth2 request')
+        response_type = kw.pop('response_type', 'code')
+        return '%s%s?%s' % (self.auth_url, 'authorize', \
+                _encode_params(client_id = self.client_id, \
+                        response_type = response_type, \
+                        redirect_uri = redirect, **kw))
+
+    def request_access_token(self, code, redirect_uri=None):
+        '''
+        return access token as a JsonDict: {"access_token":"your-access-token","expires_in":12345678,"uid":1234}, expires_in is represented using standard unix-epoch-time
+        '''
+        redirect = redirect_uri if redirect_uri else self.redirect_uri
+        if not redirect:
+            raise APIError('21305', 'Parameter absent: redirect_uri', 'OAuth2 request')
+        r = _http_post('%s%s' % (self.auth_url, 'access_token'), \
+                client_id = self.client_id, \
+                client_secret = self.client_secret, \
+                redirect_uri = redirect, \
+                code = code, grant_type = 'authorization_code')
+        current = int(time.time())
+        expires = r.expires_in + current
+        remind_in = r.get('remind_in', None)
+        if remind_in:
+            rtime = int(remind_in) + current
+            if rtime < expires:
+                expires = rtime
+        return JsonDict(access_token=r.access_token, expires=expires, expires_in=expires, uid=r.get('uid', None))
+
+    def is_expires(self):
+        return not self.access_token or time.time() > self.expires
+
+    def __getattr__(self, attr):
+        if '__' in attr:
+            return getattr(self.get, attr)
+        return _Callable(self, attr)
+
+_METHOD_MAP = { 'GET': _HTTP_GET, 'POST': _HTTP_POST, 'UPLOAD': _HTTP_UPLOAD }
+
+class _Executable(object):
+
+    def __init__(self, client, method, path):
+        self._client = client
+        self._method = method
+        self._path = path
+
+    def __call__(self, **kw):
+        method = _METHOD_MAP[self._method]
+        if method==_HTTP_POST and 'pic' in kw:
+            method = _HTTP_UPLOAD
+        return _http_call('%s%s.json' % (self._client.api_url, self._path), method, self._client.access_token, **kw)
+
+    def __str__(self):
+        return '_Executable (%s %s)' % (self._method, self._path)
+
+    __repr__ = __str__
+
+class _Callable(object):
+
+    def __init__(self, client, name):
+        self._client = client
+        self._name = name
+
+    def __getattr__(self, attr):
+        if attr=='get':
+            return _Executable(self._client, 'GET', self._name)
+        if attr=='post':
+            return _Executable(self._client, 'POST', self._name)
+        name = '%s/%s' % (self._name, attr)
+        return _Callable(self._client, name)
+
+    def __str__(self):
+        return '_Callable (%s)' % self._name
+
+    __repr__ = __str__
+
diff --git a/PythonSDK/michaelliao-sinaweibopy-2e8ee51/weibo.py~ b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/weibo.py~
new file mode 100644
index 0000000..ccab475
--- /dev/null
+++ b/PythonSDK/michaelliao-sinaweibopy-2e8ee51/weibo.py~
@@ -0,0 +1,306 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+__version__ = '1.0.9'
+__author__ = 'Liao Xuefeng (askxuefeng@gmail.com)'
+
+'''
+Python client SDK for sina weibo API using OAuth 2.
+'''
+
+try:
+    import json
+except ImportError:
+    import simplejson as json
+
+try:
+    from cStringIO import StringIO
+except ImportError:
+    from StringIO import StringIO
+
+import gzip, time, hmac, base64, hashlib, urllib, urllib2, logging, mimetypes
+
+class APIError(StandardError):
+    '''
+    raise APIError if receiving json message indicating failure.
+    '''
+    def __init__(self, error_code, error, request):
+        self.error_code = error_code
+        self.error = error
+        self.request = request
+        StandardError.__init__(self, error)
+
+    def __str__(self):
+        return 'APIError: %s: %s, request: %s' % (self.error_code, self.error, self.request)
+
+def _parse_json(s):
+    ' parse str into JsonDict '
+
+    def _obj_hook(pairs):
+        ' convert json object to python object '
+        o = JsonDict()
+        for k, v in pairs.iteritems():
+            o[str(k)] = v
+        return o
+    return json.loads(s, object_hook=_obj_hook)
+
+class JsonDict(dict):
+    ' general json object that allows attributes to be bound to and also behaves like a dict '
+    def __getattr__(self, attr):
+        return self[attr]
+
+    def __setattr__(self, attr, value):
+        self[attr] = value
+
+    def __getstate__(self):
+        return self.copy()
+
+    def __setstate__(self, state):
+        self.update(state)
+
+def _encode_params(**kw):
+    ' do url-encode parameters '
+    args = []
+    for k, v in kw.iteritems():
+        qv = v.encode('utf-8') if isinstance(v, unicode) else str(v)
+        args.append('%s=%s' % (k, urllib.quote(qv)))
+    return '&'.join(args)
+
+def _encode_multipart(**kw):
+    ' build a multipart/form-data body with randomly generated boundary '
+    boundary = '----------%s' % hex(int(time.time() * 1000))
+    data = []
+    for k, v in kw.iteritems():
+        data.append('--%s' % boundary)
+        if hasattr(v, 'read'):
+            # file-like object:
+            filename = getattr(v, 'name', '')
+            content = v.read()
+            data.append('Content-Disposition: form-data; name="%s"; filename="hidden"' % k)
+            data.append('Content-Length: %d' % len(content))
+            data.append('Content-Type: %s\r\n' % _guess_content_type(filename))
+            data.append(content)
+        else:
+            data.append('Content-Disposition: form-data; name="%s"\r\n' % k)
+            data.append(v.encode('utf-8') if isinstance(v, unicode) else v)
+    data.append('--%s--\r\n' % boundary)
+    return '\r\n'.join(data), boundary
+
+def _guess_content_type(url):
+    n = url.rfind('.')
+    if n==(-1):
+        return 'application/octet-stream'
+    ext = url[n:]
+    mimetypes.types_map.get(ext, 'application/octet-stream')
+
+_HTTP_GET = 0
+_HTTP_POST = 1
+_HTTP_UPLOAD = 2
+
+def _http_get(url, authorization=None, **kw):
+    logging.info('GET %s' % url)
+    return _http_call(url, _HTTP_GET, authorization, **kw)
+
+def _http_post(url, authorization=None, **kw):
+    logging.info('POST %s' % url)
+    return _http_call(url, _HTTP_POST, authorization, **kw)
+
+def _http_upload(url, authorization=None, **kw):
+    logging.info('MULTIPART POST %s' % url)
+    return _http_call(url, _HTTP_UPLOAD, authorization, **kw)
+
+def _read_body(obj):
+    using_gzip = obj.headers.get('Content-Encoding', '')=='gzip'
+    body = obj.read()
+    if using_gzip:
+        logging.info('gzip content received.')
+        gzipper = gzip.GzipFile(fileobj=StringIO(body))
+        fcontent = gzipper.read()
+        gzipper.close()
+        return fcontent
+    return body
+
+def _http_call(the_url, method, authorization, **kw):
+    '''
+    send an http request and return a json object if no error occurred.
+    '''
+    params = None
+    boundary = None
+    if method==_HTTP_UPLOAD:
+        # fix sina upload url:
+        the_url = the_url.replace('https://api.', 'https://upload.api.')
+        params, boundary = _encode_multipart(**kw)
+    else:
+        params = _encode_params(**kw)
+        if '/remind/' in the_url:
+            # fix sina remind api:
+            the_url = the_url.replace('https://api.', 'https://rm.api.')
+    http_url = '%s?%s' % (the_url, params) if method==_HTTP_GET else the_url
+    http_body = None if method==_HTTP_GET else params
+    req = urllib2.Request(http_url, data=http_body)
+    req.add_header('Accept-Encoding', 'gzip')
+    if authorization:
+        req.add_header('Authorization', 'OAuth2 %s' % authorization)
+    if boundary:
+        req.add_header('Content-Type', 'multipart/form-data; boundary=%s' % boundary)
+    try:
+        resp = urllib2.urlopen(req)
+        body = _read_body(resp)
+        r = _parse_json(body)
+        if hasattr(r, 'error_code'):
+            raise APIError(r.error_code, r.get('error', ''), r.get('request', ''))
+        return r
+    except urllib2.HTTPError, e:
+        try:
+            r = _parse_json(_read_body(e))
+        except:
+            r = None
+        if hasattr(r, 'error_code'):
+            raise APIError(r.error_code, r.get('error', ''), r.get('request', ''))
+        raise e
+
+class HttpObject(object):
+
+    def __init__(self, client, method):
+        self.client = client
+        self.method = method
+
+    def __getattr__(self, attr):
+        def wrap(**kw):
+            if self.client.is_expires():
+                raise APIError('21327', 'expired_token', attr)
+            return _http_call('%s%s.json' % (self.client.api_url, attr.replace('__', '/')), self.method, self.client.access_token, **kw)
+        return wrap
+
+class APIClient(object):
+    '''
+    API client using synchronized invocation.
+    '''
+    def __init__(self, app_key, app_secret, redirect_uri=None, response_type='code', domain='api.weibo.com', version='2'):
+        self.client_id = str(app_key)
+        self.client_secret = str(app_secret)
+        self.redirect_uri = redirect_uri
+        self.response_type = response_type
+        self.auth_url = 'https://%s/oauth2/' % domain
+        self.api_url = 'https://%s/%s/' % (domain, version)
+        self.access_token = None
+        self.expires = 0.0
+        self.get = HttpObject(self, _HTTP_GET)
+        self.post = HttpObject(self, _HTTP_POST)
+        self.upload = HttpObject(self, _HTTP_UPLOAD)
+
+    def parse_signed_request(self, signed_request):
+        '''
+        parse signed request when using in-site app.
+
+        Returns:
+            dict object like { 'uid': 12345, 'access_token': 'ABC123XYZ', 'expires': unix-timestamp },
+            or None if parse failed.
+        '''
+
+        def _b64_normalize(s):
+            appendix = '=' * (4 - len(s) % 4)
+            return s.replace('-', '+').replace('_', '/') + appendix
+
+        sr = str(signed_request)
+        logging.info('parse signed request: %s' % sr)
+        enc_sig, enc_payload = sr.split('.', 1)
+        sig = base64.b64decode(_b64_normalize(enc_sig))
+        data = _parse_json(base64.b64decode(_b64_normalize(enc_payload)))
+        if data['algorithm'] != u'HMAC-SHA256':
+            return None
+        expected_sig = hmac.new(self.client_secret, enc_payload, hashlib.sha256).digest();
+        if expected_sig==sig:
+            data.user_id = data.uid = data.get('user_id', None)
+            data.access_token = data.get('oauth_token', None)
+            expires = data.get('expires', None)
+            if expires:
+                data.expires = data.expires_in = time.time() + expires
+            return data
+        return None
+
+    def set_access_token(self, access_token, expires):
+        self.access_token = str(access_token)
+        self.expires = float(expires)
+
+    def get_authorize_url(self, redirect_uri=None, **kw):
+        '''
+        return the authorization url that the user should be redirected to.
+        '''
+        redirect = redirect_uri if redirect_uri else self.redirect_uri
+        if not redirect:
+            raise APIError('21305', 'Parameter absent: redirect_uri', 'OAuth2 request')
+        response_type = kw.pop('response_type', 'code')
+        return '%s%s?%s' % (self.auth_url, 'authorize', \
+                _encode_params(client_id = self.client_id, \
+                        response_type = response_type, \
+                        redirect_uri = redirect, **kw))
+
+    def request_access_token(self, code, redirect_uri=None):
+        '''
+        return access token as a JsonDict: {"access_token":"your-access-token","expires_in":12345678,"uid":1234}, expires_in is represented using standard unix-epoch-time
+        '''
+        redirect = redirect_uri if redirect_uri else self.redirect_uri
+        if not redirect:
+            raise APIError('21305', 'Parameter absent: redirect_uri', 'OAuth2 request')
+        r = _http_post('%s%s' % (self.auth_url, 'access_token'), \
+                client_id = self.client_id, \
+                client_secret = self.client_secret, \
+                redirect_uri = redirect, \
+                code = code, grant_type = 'authorization_code')
+        current = int(time.time())
+        expires = r.expires_in + current
+        remind_in = r.get('remind_in', None)
+        if remind_in:
+            rtime = int(remind_in) + current
+            if rtime < expires:
+                expires = rtime
+        return JsonDict(access_token=r.access_token, expires=expires, expires_in=expires, uid=r.get('uid', None))
+
+    def is_expires(self):
+        return not self.access_token or time.time() > self.expires
+
+    def __getattr__(self, attr):
+        if '__' in attr:
+            return getattr(self.get, attr)
+        return _Callable(self, attr)
+
+_METHOD_MAP = { 'GET': _HTTP_GET, 'POST': _HTTP_POST, 'UPLOAD': _HTTP_UPLOAD }
+
+class _Executable(object):
+
+    def __init__(self, client, method, path):
+        self._client = client
+        self._method = method
+        self._path = path
+
+    def __call__(self, **kw):
+        method = _METHOD_MAP[self._method]
+        if method==_HTTP_POST and 'pic' in kw:
+            method = _HTTP_UPLOAD
+        return _http_call('%s%s.json' % (self._client.api_url, self._path), method, self._client.access_token, **kw)
+
+    def __str__(self):
+        return '_Executable (%s %s)' % (self._method, self._path)
+
+    __repr__ = __str__
+
+class _Callable(object):
+
+    def __init__(self, client, name):
+        self._client = client
+        self._name = name
+
+    def __getattr__(self, attr):
+        if attr=='get':
+            return _Executable(self._client, 'GET', self._name)
+        if attr=='post':
+            return _Executable(self._client, 'POST', self._name)
+        name = '%s/%s' % (self._name, attr)
+        return _Callable(self._client, name)
+
+    def __str__(self):
+        return '_Callable (%s)' % self._name
+
+    __repr__ = __str__
+
-- 
1.7.10.4

